package machineconfigserver

import (
	"context"
	"fmt"
	"time"

	"github.com/blang/semver"
	"github.com/go-logr/logr"
	hyperv1 "github.com/openshift/hypershift/api/v1alpha1"
	"github.com/openshift/hypershift/control-plane-operator/releaseinfo"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/client-go/tools/record"
	"k8s.io/client-go/util/workqueue"
	ctrl "sigs.k8s.io/controller-runtime"
	ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

const (
	finalizer = "hypershift.openshift.io/finalizer"
)

var NoopReconcile controllerutil.MutateFn = func() error { return nil }

// MachineConfigServerReconciler reconciles machineConfigServer resources.
// For a given release it generates a machine config server serving ignition content,
// exposes the endpoint with a route and generates a user-data secret which references the endpoint
// TODO (alberto): Currently this controller only manages the resources associated to the mcs, i.e
// deployment and rbac resources. Something needs to generate the pki resources for each MCS resource
// which are currently statically generated by the HCP.
type MachineConfigServerReconciler struct {
	ctrlclient.Client
	recorder        record.EventRecorder
	Log             logr.Logger
	ReleaseProvider releaseinfo.Provider
}

func (r *MachineConfigServerReconciler) SetupWithManager(mgr ctrl.Manager) error {
	_, err := ctrl.NewControllerManagedBy(mgr).
		For(&hyperv1.MachineConfigServer{}).
		WithOptions(controller.Options{
			RateLimiter: workqueue.NewItemExponentialFailureRateLimiter(1*time.Second, 10*time.Second),
		}).
		WithEventFilter(predicate.GenerationChangedPredicate{}).
		Build(r)
	if err != nil {
		return fmt.Errorf("failed setting up with a controller manager %w", err)
	}

	r.recorder = mgr.GetEventRecorderFor("machine-config-server-controller")

	return nil
}

func (r *MachineConfigServerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	r.Log = ctrl.LoggerFrom(ctx)
	r.Log.Info("Reconciling")

	mcs := &hyperv1.MachineConfigServer{}
	err := r.Client.Get(ctx, req.NamespacedName, mcs)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return ctrl.Result{}, nil
		}
		return ctrl.Result{}, err
	}

	releaseImage, err := r.ReleaseProvider.Lookup(ctx, mcs.Spec.ReleaseImage)
	if err != nil {
		return ctrl.Result{}, err
	}
	r.Log = r.Log.WithValues("releaseImage", mcs.Spec.ReleaseImage, "version", releaseImage.Version())

	// Generate mcs manifests for the given release
	mcsServiceAccount := ServiceAccount{
		Name:      mcs.GetName(),
		Namespace: mcs.GetNamespace(),
	}.Build()

	mcsRoleBinding := RoleBinding{
		Name:           mcs.GetName(),
		ServiceAccount: mcsServiceAccount,
	}.Build()

	mcsService := Service{
		Name:      mcs.GetName(),
		Namespace: mcs.GetNamespace(),
	}.Build()

	mcsDeployment := Deployment{
		Name:           mcs.GetName(),
		Namespace:      mcs.GetNamespace(),
		ServiceAccount: mcsServiceAccount,
		Images:         releaseImage.ComponentImages(),
	}.Build()

	ignitionRoute := IgnitionRoute{
		Name:      mcs.GetName(),
		Namespace: mcs.GetNamespace(),
	}.Build()

	userDataSecret := Userdata{
		Name:      mcs.GetName(),
		Namespace: mcs.GetNamespace(),
	}.Build()

	// Return early if deleted
	if !mcs.DeletionTimestamp.IsZero() {
		if err := r.Delete(ctx, mcsServiceAccount); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if err := r.Delete(ctx, mcsRoleBinding); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if err := r.Delete(ctx, mcsService); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if err := r.Delete(ctx, mcsDeployment); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if err := r.Delete(ctx, ignitionRoute); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if err := r.Delete(ctx, userDataSecret); err != nil && !apierrors.IsNotFound(err) {
			return ctrl.Result{}, err
		}

		if controllerutil.ContainsFinalizer(mcs, finalizer) {
			controllerutil.RemoveFinalizer(mcs, finalizer)
			if err := r.Update(ctx, mcs); err != nil {
				return ctrl.Result{}, fmt.Errorf("failed to remove finalizer from cluster: %w", err)
			}
		}
		return ctrl.Result{}, nil
	}

	// Ensure the machineConfigServer has a finalizer for cleanup
	if !controllerutil.ContainsFinalizer(mcs, finalizer) {
		controllerutil.AddFinalizer(mcs, finalizer)
		if err := r.Update(ctx, mcs); err != nil {
			return ctrl.Result{}, fmt.Errorf("failed to add finalizer to hostedControlPlane: %w", err)
		}
	}

	_, err = controllerutil.CreateOrUpdate(ctx, r.Client, mcsServiceAccount, NoopReconcile)
	if err != nil {
		return ctrl.Result{}, err
	}

	_, err = controllerutil.CreateOrUpdate(ctx, r.Client, mcsRoleBinding, NoopReconcile)
	if err != nil {
		return ctrl.Result{}, err
	}

	_, err = controllerutil.CreateOrUpdate(ctx, r.Client, mcsDeployment, func() error {
		// Regenerate deployment for latest release
		mcsDeployment = Deployment{
			Name:           mcs.GetName(),
			Namespace:      mcs.GetNamespace(),
			ServiceAccount: mcsServiceAccount,
			Images:         releaseImage.ComponentImages(),
		}.Build()
		return nil
	})
	if err != nil {
		return ctrl.Result{}, err
	}

	_, err = controllerutil.CreateOrUpdate(ctx, r.Client, mcsService, NoopReconcile)
	if err != nil {
		return ctrl.Result{}, err
	}

	r.Log.Info("Creating ignition provider route")
	_, err = controllerutil.CreateOrUpdate(ctx, r.Client, ignitionRoute, NoopReconcile)
	if err != nil {
		return ctrl.Result{}, err
	}
	if err := r.Get(ctx, ctrlclient.ObjectKeyFromObject(ignitionRoute), ignitionRoute); err != nil {
		return ctrl.Result{}, err
	}
	if ignitionRoute.Spec.Host == "" {
		r.Log.Info("Waiting for ignition route to be available")
		return ctrl.Result{Requeue: true}, nil
	}

	r.Log.Info("Creating userdata secret")
	semversion, err := semver.Parse(releaseImage.Version())
	if err != nil {
		return ctrl.Result{}, nil
	}
	userDataSecret = Userdata{
		Name:                 mcs.GetName(),
		Namespace:            mcs.GetNamespace(),
		IgnitionProviderAddr: ignitionRoute.Spec.Host,
		Version:              semversion,
	}.Build()
	if err := r.Create(ctx, userDataSecret); err != nil && !apierrors.IsAlreadyExists(err) {
		return ctrl.Result{}, fmt.Errorf("failed to generate user data secret: %w", err)
	}

	mcs.Status.Version = releaseImage.Version()
	mcs.Status.Host = ignitionRoute.Spec.Host
	if err := r.Status().Update(ctx, mcs); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}
